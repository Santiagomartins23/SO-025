# 🧵💡 Problema do Produtor e Consumidor com Pthreads e Semáforos (POSIX)

### Nesta seção, solucionamos o problema proposto na entrega da atividade, utilizando semáforos POSIX e exclusão mútua com mutexes, controlando o acesso concorrente
ao buffer compartilhado. A implementação garante sincronização correta entre produtor e consumidor, evita espera ociosa, e simula comportamento real de multitarefa.

---

## ✅ Requisitos Atendidos

| Buffer limitado compartilhado  ✅ |
| Controle de exclusão mútua  ✅ (`pthread_mutex_t`) |
| Controle de posições livres/ocupadas ✅ (`sem_t empty/full`) |
| Capacidade de colocar thread em espera  ✅ (`sem_wait()`) |
| Capacidade de "acordar" threads  ✅ (`sem_post()`) |
| Controle de leitura/escrita com ponteiros  ✅ (`in` e `out`) |

---

## 🧠 Funcionamento

- O **produtor** insere itens no buffer, esperando espaço livre (`empty`) e travando o mutex para exclusividade.
- O **consumidor** retira itens do buffer, esperando por itens disponíveis (`full`) e também usando mutex para exclusão mútua.
- Ambos usam um buffer circular com índices `in` (escrita) e `out` (leitura), que se reiniciam com `% BUFFER_SIZE`.

---

## 🔐 Controle de Concorrência

### Semáforos
- `sem_t empty`: Conta quantas posições estão **vazias** no buffer. Inicia com `BUFFER_SIZE`.
- `sem_t full`: Conta quantas posições estão **ocupadas**. Inicia com `0`.

### Exclusão Mútua
- `pthread_mutex_t mutex`: Impede que duas threads modifiquem simultaneamente o buffer.

---


